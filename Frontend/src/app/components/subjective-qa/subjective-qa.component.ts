import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormControl } from '@angular/forms';
import { InterviewService, ChatRequest } from '../../services/interview.service';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

interface SubjectiveQuestion {
  id: string;
  question: string;
  domain: string;
  experienceLevel: string;
}

interface SubjectiveAnswer {
  questionId: string;
  answer: string;
  similarity?: number;
  correct?: boolean;
  evaluated?: boolean;
  lastEvaluatedAnswer?: string;  // Track what was last evaluated
}

@Component({
  selector: 'app-subjective-qa',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './subjective-qa.component.html',
  styleUrls: ['./subjective-qa.component.css']
})
export class SubjectiveQAComponent implements OnInit {
  @Input() domain: string = '';
  @Input() resumeId: string = '';
  @Input() currentQuestionIndex: number = 0;
  @Output() answersUpdate = new EventEmitter<SubjectiveAnswer[]>();

  questions: SubjectiveQuestion[] = [];
  answerControl = new FormControl('');
  answers: SubjectiveAnswer[] = [];
  private evaluationInProgress = new Set<string>(); // Track ongoing evaluations

  constructor(private interviewService: InterviewService) {}

  ngOnInit() {
    this.loadQuestions();
    this.setupAnswerControl();
  }

  ngOnChanges() {
    // When question index changes, update the answer control
    this.updateAnswerControl();
  }

  private loadQuestions() {
    // Simple demo questions - expected answers will be generated by AI
    this.questions = [
      {
        id: 'subj_1',
        question: 'Explain the difference between synchronous and asynchronous programming. Provide examples of when you would use each approach.',
        domain: this.domain || 'Software Development',
        experienceLevel: 'intermediate'
      },
      {
        id: 'subj_2', 
        question: 'Describe your experience with database optimization. What techniques have you used to improve query performance?',
        domain: this.domain || 'Software Development',
        experienceLevel: 'intermediate'
      },
      {
        id: 'subj_3',
        question: 'How do you approach debugging a complex issue in a production environment? Walk through your process.',
        domain: this.domain || 'Software Development', 
        experienceLevel: 'intermediate'
      },
      {
        id: 'subj_4',
        question: 'Explain the concept of microservices architecture. What are the benefits and challenges of implementing microservices?',
        domain: this.domain || 'Software Development',
        experienceLevel: 'senior'
      }
    ];
  }

  private setupAnswerControl() {
    this.answerControl.valueChanges
      .pipe(debounceTime(500), distinctUntilChanged())
      .subscribe(value => {
        this.saveCurrentAnswer(value || '');
      });
  }

  private updateAnswerControl() {
    const currentQuestion = this.getCurrentQuestion();
    if (currentQuestion) {
      const existingAnswer = this.answers.find(a => a.questionId === currentQuestion.id);
      this.answerControl.setValue(existingAnswer?.answer || '', { emitEvent: false });
    }
  }

  getCurrentQuestion(): SubjectiveQuestion | null {
    return this.questions[this.currentQuestionIndex] || null;
  }

  private saveCurrentAnswer(answer: string) {
    const currentQuestion = this.getCurrentQuestion();
    if (currentQuestion) {
      const existingIndex = this.answers.findIndex(a => a.questionId === currentQuestion.id);
      const answerData: SubjectiveAnswer = {
        questionId: currentQuestion.id,
        answer: answer,
        evaluated: false
      };

      if (existingIndex >= 0) {
        // Preserve evaluation status and similarity if answer hasn't changed much
        const existingAnswer = this.answers[existingIndex];
        if (existingAnswer.lastEvaluatedAnswer) {
          answerData.similarity = existingAnswer.similarity;
          answerData.correct = existingAnswer.correct;
          answerData.evaluated = existingAnswer.evaluated;
          answerData.lastEvaluatedAnswer = existingAnswer.lastEvaluatedAnswer;
        }
        this.answers[existingIndex] = answerData;
      } else {
        this.answers.push(answerData);
      }

      this.answersUpdate.emit(this.answers);

      // Only trigger AI evaluation if answer has changed significantly
      this.evaluateAnswerSilently(currentQuestion, answer, existingIndex >= 0 ? existingIndex : this.answers.length - 1);
    }
  }

  private async evaluateAnswerSilently(question: SubjectiveQuestion, userAnswer: string, answerIndex: number) {
    // Skip evaluation if answer is too short
    if (!userAnswer.trim() || userAnswer.length < 10) {
      return;
    }

    // Check if evaluation is already in progress for this question
    if (this.evaluationInProgress.has(question.id)) {
      console.log('Evaluation already in progress for question:', question.id);
      return;
    }

    // Check if this answer has already been evaluated (avoid duplicates)
    const existingAnswer = this.answers[answerIndex];
    if (existingAnswer && existingAnswer.lastEvaluatedAnswer) {
      const similarity = this.calculateTextSimilarity(userAnswer, existingAnswer.lastEvaluatedAnswer);
      if (similarity > 0.9) { // 90% similar - don't re-evaluate
        console.log('Answer too similar to last evaluated, skipping evaluation');
        return;
      }
    }

    // Mark evaluation as in progress
    this.evaluationInProgress.add(question.id);

    try {
      const chatRequest: ChatRequest = {
        questionText: question.question,        // Actual interview question
        userAnswer: userAnswer,                 // User's typed answer
        resumeId: this.resumeId,
        domain: this.domain,
        questionType: 'SUBJECTIVE'
      };

      console.log('Starting AI evaluation for question:', question.id);
      const response = await this.interviewService.sendChatResponse(chatRequest).toPromise();
      
      if (response && answerIndex < this.answers.length) {
        // Update answer with AI evaluation results
        this.answers[answerIndex] = {
          ...this.answers[answerIndex],
          similarity: response.similarity,
          correct: response.correct,
          evaluated: true,
          lastEvaluatedAnswer: userAnswer  // Track what was evaluated
        };
        
        console.log('AI evaluation completed. Similarity:', response.similarity);
        // Emit updated answers for scoring calculation
        this.answersUpdate.emit(this.answers);
      }
    } catch (error) {
      console.error('Silent AI evaluation failed:', error);
      // Mark as evaluated even if failed to avoid repeated attempts
      if (answerIndex < this.answers.length) {
        this.answers[answerIndex].evaluated = true;
        this.answers[answerIndex].lastEvaluatedAnswer = userAnswer;
      }
    } finally {
      // Remove from in-progress tracking
      this.evaluationInProgress.delete(question.id);
    }
  }

  // Simple text similarity check to avoid re-evaluating similar answers
  private calculateTextSimilarity(text1: string, text2: string): number {
    if (!text1 || !text2) return 0;
    
    const a = text1.toLowerCase().trim();
    const b = text2.toLowerCase().trim();
    
    if (a === b) return 1;
    
    // Simple word-based similarity
    const wordsA = a.split(/\s+/);
    const wordsB = b.split(/\s+/);
    const allWords = new Set([...wordsA, ...wordsB]);
    const intersection = wordsA.filter(word => wordsB.includes(word));
    
    return intersection.length / allWords.size;
  }

  clearAnswer() {
    this.answerControl.setValue('');
  }

  getAnsweredCount(): number {
    return this.answers.filter(a => a.answer.trim().length > 0).length;
  }

  getTotalQuestions(): number {
    return this.questions.length;
  }
} 